<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>int数组 integer数组 list相互转换</title>
    <url>/2023/09/10/JAVA/int%E6%95%B0%E7%BB%84%20integer%E6%95%B0%E7%BB%84%20list%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] intArray1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int[] 转 List&lt;Integer&gt;</span></span><br><span class="line">    List&lt;Integer&gt; listInteger1 =IntStream.of(intArray1)   <span class="comment">//先把int[]转成IntStream</span></span><br><span class="line">                                .boxed()                  <span class="comment">//再把IntStream转成Stream&lt;Integer&gt;</span></span><br><span class="line">                                .collect(Collectors.toList());  <span class="comment">//再把Stream&lt;Integer&gt;转成List&lt;Integer&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int[] 转 Integer[]</span></span><br><span class="line">    Integer[] IntegerArray1 = IntStream.of(intArray1)     <span class="comment">//先把int[]转成IntStream</span></span><br><span class="line">                                .boxed()                  <span class="comment">//再把IntStream转成Stream&lt;Integer&gt;</span></span><br><span class="line">                                .toArray(Integer[]::<span class="keyword">new</span>); <span class="comment">//用toArray方法，传入IntFunction&lt;A[]&gt; generator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; 转 int[]</span></span><br><span class="line">    <span class="type">int</span>[] intArray2 = listInteger1.stream()               <span class="comment">//先把List&lt;Integer&gt;转成Stream&lt;Integer&gt;</span></span><br><span class="line">                        .mapToInt(Integer::valueOf)       <span class="comment">//把Stream&lt;Integer&gt;转成IntStream</span></span><br><span class="line">                        .toArray();                       <span class="comment">//把IntStream转成int[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Integer[] 转 int[]</span></span><br><span class="line">    <span class="type">int</span>[] intArray3 = Arrays.stream(IntegerArray1)        <span class="comment">//把Integer[]转成Stream&lt;Integer&gt;</span></span><br><span class="line">                        .mapToInt(Integer::valueOf)       <span class="comment">//把Stream&lt;Integer&gt;转成IntStream</span></span><br><span class="line">                        .toArray();                       <span class="comment">//把IntStream转成int[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; 转 Integer[]</span></span><br><span class="line">    Integer[] IntegerArray2 = listInteger1.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Integer[] 转 List&lt;Integer&gt;</span></span><br><span class="line">    List&lt;Integer&gt; listInteger2 = Arrays.asList(IntegerArray2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>JAVA</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-GC-回收器</title>
    <url>/2023/09/11/JVM/GC-%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-垃圾回收器"><a href="#1-垃圾回收器" class="headerlink" title="1.垃圾回收器"></a>1.垃圾回收器</h1><h2 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h2><p>按线程数分，可以分为<code>串行</code>垃圾回收器和<code>并行</code>垃圾回收器。 <code>cpu</code></p>
<ul>
<li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
</li>
<li><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p>
</li>
</ul>
<p>按照工作模式分，可以分为<code>并发式</code>垃圾回收器和<code>独占式</code>垃圾回收器。 <code>线程</code></p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
</ul>
<p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>
<h2 id="评估性能指标"><a href="#评估性能指标" class="headerlink" title="评估性能指标"></a>评估性能指标</h2><ul>
<li>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>内存占用：Java堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
<p>简单来说，主要抓住两点：吞吐量、暂停时间</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 &#x3D; 0.4</p>
<h3 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p>
<p>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p>
<p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</p>
<h1 id="2-常见回收器"><a href="#2-常见回收器" class="headerlink" title="2.常见回收器"></a>2.常见回收器</h1><ul>
<li>串行回收器：Serial、Serial Old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G1</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.jpg"
                      alt="images"
                ></p>
<h3 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h3><p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p>
<p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<p> Serial old是运行在Client模式下默认的老年代的垃圾回收器<br> Serial 0ld在Server模式下主要有两个用途：① 与新生代的Parallel scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>
<p>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</p>
<p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC</p>
<h3 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h3><p>ParNew收集器是Serial收集器的多线程版本。Par是Parallel的缩写，New：只能处理的是新生代<br>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</p>
<p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p> 对于新生代，回收次数频繁，使用并行方式高效。<br> 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-comment"></i><p>Note</p>
</div><div class="notel-content"><ul>
<li>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
<p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>
<p>在程序中，开发人员可以通过选项<code>-XX:+UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU数据相同的线程数。</p>
</div></div>

<h3 id="Parallel-Scavenge-吞吐量优先"><a href="#Parallel-Scavenge-吞吐量优先" class="headerlink" title="Parallel Scavenge 吞吐量优先"></a>Parallel Scavenge 吞吐量优先</h3><p>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。<br>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</p>
<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。<br>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。<br>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>关注点缩短停顿时间，以获取最短回收停顿时间的垃圾收集器。</p>
<p>CMS收集器是基于“标记-清除”算法实现的（会产生碎片，为什么不使用压缩呢？</p>
<blockquote>
<p>因为与用户线程是并发的，所以重新整理会影响用户线程的执行</p>
</blockquote>
<p>整个过程分为4个步骤：</p>
<ol>
<li>初始标记：标记GC Roots能直接关联到的对象，速度很快，但耗时很短。会stw</li>
<li>并发标记：进行GC Roots Tracing的过程，遍历整个图对象时间较长，但可以与用户程序<code>并发</code>执行。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，仍然需要停顿。但停顿时间会短很多，因为仅重新标记用户线程。<em>注意：</em> 不包括标记新增对象。</li>
<li>并发清除：清除标记阶段未清除的对象，可以与用户程序<code>并发</code>执行。</li>
</ol>
<div class="note default"><p>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制<br>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p>
</div> 

<blockquote>
<p>总结</p>
<ul>
<li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li>
</ul>
</blockquote>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-comment"></i><p>优势</p>
</div><div class="notel-content"><ul>
<li>并行回收 并发回收 </li>
<li>分代收集<br>   从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。<br>   将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。<br>   和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
<li>空间整合 region之间是复制算法 整体上看作为标记压缩 避免碎片</li>
<li>可预测的时间停顿 （软实时）<br>  这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
</div></div>

<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-comment"></i><p>缺点</p>
</div><div class="notel-content"><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>
</div></div>

<h4 id="region"><a href="#region" class="headerlink" title="region"></a>region</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/JVM/G1Region.jpg"
                      alt="images"
                ></p>
<p>一个region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p>
<p>设置H的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p>每个Region都是通过指针碰撞来分配空间</p>
<h4 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a>G1垃圾回收器的回收过程</h4><ol>
<li><p>年轻代GC（Young GC） </p>
</li>
<li><p>老年代并发标记过程（Concurrent Marking） </p>
</li>
<li><p>混合回收（Mixed GC）<br>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>
</li>
</ol>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-comment"></i><p>Note</p>
</div><div class="notel-content"><p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
</div></div>

<h4 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h4><p>抛出问题：一个eden区的对象被old区对象引用 若回收新生代 则要遍历老年代 </p>
<p>每个Region都有一个对应的Remembered Set 记录了被引用的对象</p>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/JVM/rememberset.jpg"
                      alt="images"
                ></p>
<h4 id="G1垃圾回收器的回收过程-1"><a href="#G1垃圾回收器的回收过程-1" class="headerlink" title="G1垃圾回收器的回收过程"></a>G1垃圾回收器的回收过程</h4><p>暂且略 太复杂</p>
<h1 id="3-7款经典收集器与垃圾分代之间的关系"><a href="#3-7款经典收集器与垃圾分代之间的关系" class="headerlink" title="3.7款经典收集器与垃圾分代之间的关系"></a>3.7款经典收集器与垃圾分代之间的关系</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/JVM/%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%B8%A6%E5%8C%BA%E5%85%B3%E7%B3%BB.jpg"
                      alt="images"
                ></p>
<h2 id="回收器组合关系"><a href="#回收器组合关系" class="headerlink" title="回收器组合关系"></a>回收器组合关系</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/JVM/%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.jpg"
                      alt="images"
                ></p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-thin"></i><p>fa-comment</p>
</div><div class="notel-content"><ol>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1；</li>
<li>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366）</li>
<li>（绿色虚框）JDK14中：删除CMS垃圾回收器（JEP363）</li>
</ol>
</div></div>







]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>集合基操</title>
    <url>/2023/09/10/JAVA/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line">list.sort(Comparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个list</span></span><br><span class="line">list.addAll(list2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转为stream 筛选</span></span><br><span class="line">list.stream().filter(e -&gt; e.getId() == <span class="number">1</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>JAVA</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-GC-概述及算法</title>
    <url>/2023/09/11/JVM/GC-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1. 垃圾回收算法"></a>1. 垃圾回收算法</h1><h2 id="1-1-标记阶段"><a href="#1-1-标记阶段" class="headerlink" title="1.1 标记阶段"></a>1.1 标记阶段</h2><p>判断对象存活一般有两种方式：引用计数算法和可达性分析算法。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。<br>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<blockquote>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
</blockquote>
<blockquote>
<p>缺点：</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li>
<li>用计数器有一个严重的问题，即无法处理<code>循环引用</code>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
</blockquote>
<h3 id="可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>可达性分析算法（根搜索算法、追踪性垃圾收集）</h3><p>基本思路</p>
<blockquote>
<p>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。<br>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）<br>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。<br>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
</blockquote>
<h3 id="GC-Roots包括以下几类元素："><a href="#GC-Roots包括以下几类元素：" class="headerlink" title="GC Roots包括以下几类元素："></a>GC Roots包括以下几类元素：</h3><ul>
<li>虚拟机栈中引用的对象 比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象  比如：Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象 比如：字符串常量池（String Table）里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>
<p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p>
<p>小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-thin"></i><p>注意</p>
</div><div class="notel-content"><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。<br>这点也是导致GC进行时必须“stop The World”的一个重要原因。<br>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
</div></div>

<h2 id="1-2-对象的finalization机制"><a href="#1-2-对象的finalization机制" class="headerlink" title="1.2 对象的finalization机制"></a>1.2 对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>
<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<p>永远不要主动调用某个对象的finalize()方法I应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>在finalize()时可能会导致对象复活。</li>
<li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li>
<li>一个糟糕的finalize()会严重影响Gc的性能。</li>
</ul>
<p>从功能上来说，finalize()方法与C中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C中的析构函数。</p>
<p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li>可触及的：从根节点开始，可以到达这个对象。</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</li>
</ul>
<p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>
<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法</li>
<li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li>
</ol>
<h2 id="1-3-清除阶段"><a href="#1-3-清除阶段" class="headerlink" title="1.3 清除阶段"></a>1.3 清除阶段</h2><p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<ol>
<li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 </li>
<li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
</ol>
<p>缺点</p>
<ul>
<li>标记清除算法的效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>
</ul>
<h4 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p>优点</p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<p>缺点</p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
<h3 id="标记-压缩（整理）算法"><a href="#标记-压缩（整理）算法" class="headerlink" title="标记-压缩（整理）算法"></a>标记-压缩（整理）算法</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>
<p>优点</p>
<ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<p>缺点</p>
<ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。<br>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<h4 id="年轻代（Young-Gen）"><a href="#年轻代（Young-Gen）" class="headerlink" title="年轻代（Young Gen）"></a>年轻代（Young Gen）</h4><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<h4 id="老年代（Tenured-Gen）"><a href="#老年代（Tenured-Gen）" class="headerlink" title="老年代（Tenured Gen）"></a>老年代（Tenured Gen）</h4><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>
<p>缺点</p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/JVM/%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.jpg"
                      alt="image-20200427110606877"
                ></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-MVCC</title>
    <url>/2023/09/06/MySQL/MVCC/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-当前读"><a href="#1-当前读" class="headerlink" title="1.当前读"></a>1.当前读</h3><p>当前读就是读取记录的最新版本，读取时还要加上锁，导致其他并发事务无法访问该记录，从而阻塞其他并发事务，因此，其并发度最低。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-快照读"><a href="#2-快照读" class="headerlink" title="2.快照读"></a>2.快照读</h3><p>快照读读取的是记录的可见版本（不一定是最新的），这个读取是基于快照的，即不加锁的。快照读不依赖事务的状态，也不依赖事务的隔离级别，因此，其并发性能最好，但是，其读取的数据可能是过时的。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3.MVCC"></a>3.MVCC</h3><p>维护一个数据的多个版本，使得读写没有冲突。其具体实现，依赖于数据库记录中的三个隐字段、undo日志、ReadView。</p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-lightbulb-on"></i><p>实现原理</p>
</div><div class="notel-content"><ul>
<li>隐藏字段<br>在每行记录后添加两个隐藏列，分别是<br>DB_TRX_ID：事务ID<br>DB_ROLL_PTR：回滚指针指向记录的上一个版本，用于配合undo log，指向上一个版本。<br>DB_ROW_ID：隐藏主键，用于在undo log中定位记录，如果表中没有主键，则会生成一个隐藏的自增ID。</li>
<li>undo日志<br>在修改操作时，不仅记录当前数据的日志，还要记录修改前的日志。修改时记录当前的数据到undolog<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/undolog.jpg"
                      alt="undo log"
                ></li>
<li>ReadView<br>ReadView记录了系统当前活跃事务的ID列表,包含一下四个字段:<blockquote>
<ol>
<li>m_ids:当前活跃的事务ID集合</li>
<li>min_trx_id:最小活跃事务ID</li>
<li>max_trx_id:预分配事务ID,当前最大事务+1（因为事务ID是自增的）</li>
<li>creator_trx_id:ReadView创建者的事务ID</li>
</ol>
</blockquote>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/readView.jpg"
                      alt="readView"
                ></p>
</div></div>

<ul>
<li>在RC隔离级别下的执行过程<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/RC-.jpg"
                      alt="readView"
                ></li>
</ul>
<hr>
<h3 id="4-事务隔离与一致原理"><a href="#4-事务隔离与一致原理" class="headerlink" title="4.事务隔离与一致原理"></a>4.事务隔离与一致原理</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5CMySQL%5C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%8E%E4%B8%80%E8%87%B4%E5%8E%9F%E7%90%86.jpg"
                      alt="readView"
                ></p>
<div class="note-large default"><div class="notel-title"><p>🔚总结</p>
</div><div class="notel-content"><ul>
<li>MVCC+锁实现隔离</li>
<li>redolog实现持久化+undolog实现回滚&#x3D;&#x3D;&gt;事务的持久性 一致 原子<blockquote>
<p>redolog（重做日志）是数据库中的一种日志文件，用于记录数据库中发生的所有更改操作，以便在发生故障时进行恢复。它记录了所有已提交的事务所做的更改，以及在故障恢复期间未提交的事务所做的更改。<br>undolog（撤消日志）是数据库中的另一种日志文件，用于记录在事务回滚期间需要撤消的更改操作。当需要回滚一个事务时，数据库会使用undolog来撤消该事务所做的更改，以便将数据库恢复到回滚之前的状态。</p>
</blockquote>
</li>
</ul>
</div></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86.jpg"
                     
                ></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-SQL优化</title>
    <url>/2023/09/09/MySQL/SQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-插入优化"><a href="#1-插入优化" class="headerlink" title="1.插入优化"></a>1.插入优化</h3><ul>
<li>多条插入</li>
<li>手动开启事务</li>
<li>主键顺序插入</li>
<li>大量插入数据时 采用load指令 加载sql文件</li>
</ul>
<h3 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2.主键优化"></a>2.主键优化</h3><ul>
<li>主键长度小</li>
<li>主键有序</li>
<li>主键不要修改</li>
<li></li>
</ul>
<h3 id="3-Order-by优化"><a href="#3-Order-by优化" class="headerlink" title="3.Order by优化"></a>3.Order by优化</h3><ul>
<li>filesort 查出数据后重新排序 慢</li>
<li>index 利用索引 较快<blockquote>
<p>可以根据需求 添加索引时指定升序还是降序 order的时候就会是用index 否则还是会filesort<br>必须是覆盖查询 否则还是要回表 use filesort<br>最左法则</p>
</blockquote>
</li>
</ul>
<h3 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4.group by优化"></a>4.group by优化</h3><ul>
<li>利用索引 且满足最左法则 则不会走临时表 原因：回到联合索引 首先根据第一个字段排序 然后根据第二个字段排排序 但是直接按第二个字段分组时 他们顺序是乱的 需要排序 就会用到临时表 如果先用第一个字段索引找到 第二个自然就是有序的了 顺序下去能够算出count了</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-引擎</title>
    <url>/2023/09/09/MySQL/INNODB%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.jpg"
                      alt="image"
                ></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-事务隔离与锁</title>
    <url>/2023/09/08/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<div class="note-large note"><div class="notel-title"><p>note</p>
</div><div class="notel-content"><p>本质上，事务隔离级别就是为了解决并发访问下的数据一致性问题的。不同的事务隔离级别，解决了不同程度的数据一致性。而我们所说的全局锁、表锁、行级锁等等，其实都是事务隔离级别的具体实现。而 MVCC、意向锁，则是一些局部的性能优化。</p>
</div></div>

<h3 id="1-事务的隔离级别"><a href="#1-事务的隔离级别" class="headerlink" title="1.事务的隔离级别"></a>1.事务的隔离级别</h3><ul>
<li><p>读未提交（Read Uncommitted）<br>读还没有提交的数据 会产生脏读 比如 事务A读取了事务B未提交的数据 然后事务B回滚了 事务A读取的数据就无效了</p>
</li>
<li><p>读已提交（Read Committed）<br>读已经提交的数据 不会产生<code>脏读 </code>但会产生<code>不可重复读</code>是指事务A读取了事务B已经提交的数据 然后事务B修改了数据 事务A再次读取的数据和第一次读取的数据不一样</p>
</li>
<li><p>可重复读（Repeatable Read）<br>这个隔离级别解决了<code>不可重复读</code>的问题，只要是在同一事务范围内，那么读取到的数据就是一样的。对于 MySQL Innodb 来说，其实通过 MVCC 来实现的。但<code>不可重复读</code>隔离级别会产生幻读问题，即对于某个<code>范围</code>的数据读取，前后两次可能读取到不同的结果。</p>
<blockquote>
<p>举个例子：数据库中有 price 为 1、3、5 三个商品，此时 A 事务查询 price &lt; 10 的商品，查询到了 3 个商品。随后 B 事务插入了一条 price 为 7 的商品。接着 A 事务继续查询 price &lt; 10 的商品，这次却查询到了 4 个商品。可以看到「幻读」与「不可重复读」是有些类似的，只是「不可重复读」更多指的是某一条记录，而「幻读」指的则是某个范围数据。对于 MySQL Innodb 来说，其通过行级锁级别的 Gap Lock 解决了幻读的问题。</p>
</blockquote>
</li>
<li><p>串行化（Serializable）<br>串行化，指的是所有事务串行执行。 这个就最简单了，不用去竞争，一个个去执行，但是效率也是最低的。</p>
</li>
</ul>
<h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2.锁"></a>2.锁</h3><ul>
<li>表级的意向排它锁（IX）：lock mode IX。</li>
<li>表级的插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention</li>
<li>行级的记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap</li>
<li>行级的间隙锁（LOCK_GAP）: lock_mode X locks gap before rec</li>
<li>行级的 Next-key 锁（LOCK_ORNIDARY）: lock_mode X<br>在 Innodb 存储引擎中，我们可以通过下面的命令来查询锁的情况。<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 开启锁的日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_status_output_locks<span class="operator">=</span><span class="keyword">on</span>; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查看innodb引擎的信息(包含锁的信息)</span><br><span class="line"><span class="keyword">show</span> engine innodb status\G;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL运维-日志</title>
    <url>/2023/09/10/MySQL/%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="1-错误日志"><a href="#1-错误日志" class="headerlink" title="1.错误日志"></a>1.错误日志</h3><p>当数据库出现错误时，错误日志会记录下来，通过错误日志可以分析出错误的原因。</p>
<h3 id="2-binlog"><a href="#2-binlog" class="headerlink" title="2.binlog"></a>2.binlog</h3><p>binlog是二进制日志文件，记录了数据库所有的DDL和DML语句（除select）<br>可以记录某一行数据变化前后的值，也可以记录某一行数据的变化过程（sql语句）<br>作用：</p>
<ul>
<li>数据恢复</li>
<li>主从复制<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-thin"></i><p>主从复制过程</p>
</div><div class="notel-content"><p>主库将数据库中数据的变化写入到 binlog从库连接主库从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</p>
</div></div></li>
</ul>
<div class="note default"><p>DDL: create,drop,alter 操作表结构<br>DML：insert,update,delete 操作表数据</p>
</div>

<h3 id="3-查询日志"><a href="#3-查询日志" class="headerlink" title="3.查询日志"></a>3.查询日志</h3><p>记录数据所有操作sql语句</p>
<h3 id="4-慢查询日志"><a href="#4-慢查询日志" class="headerlink" title="4.慢查询日志"></a>4.慢查询日志</h3><p>慢查询日志记录了所有执行时间超过long_query_time秒的sql语句 效率比较低的语句</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-视图</title>
    <url>/2023/09/07/MySQL/%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称 <span class="keyword">AS</span> 查询语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改视图 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称 <span class="keyword">AS</span> 查询语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图                                 </span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名称;                                                                             </span><br><span class="line"><span class="comment">-- 查看视图                                                     </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-检查选项cascaded"><a href="#2-检查选项cascaded" class="headerlink" title="2.检查选项cascaded"></a>2.检查选项cascaded</h3> <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"><span class="comment">-- cascaded 级联 向下传递验证</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"> <span class="comment">--- local 本地 只检查当前视图  不会再向下验证。 eg:v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，只检查v2，不会检查v2的关联视图v1。</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-视图的更新"><a href="#3-视图的更新" class="headerlink" title="3.视图的更新"></a>3.视图的更新</h3><p>视图必须与基础表一一对应才能增删改</p>
<h3 id="4-视图作用"><a href="#4-视图作用" class="headerlink" title="4.视图作用"></a>4.视图作用</h3><ul>
<li>简单 将常用的sql封装成视图 简化操作</li>
<li>安全 权限分配</li>
<li>数据独立 屏蔽真实的表结构</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-存储过程</title>
    <url>/2023/09/07/MySQL/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$ <span class="comment">-- 修改SQL语句的结束符为$$</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(参数列表) <span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 存储过程体</span></span><br><span class="line"><span class="keyword">END</span> $$ <span class="comment">-- 存储过程结束  </span></span><br><span class="line">DELIMITER ; <span class="comment">-- 修改回原来的结束符</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><ul>
<li>系统变量<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">global</span> variables <span class="comment">--支持模糊查询</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span> <span class="comment">--查看变量</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span> <span class="comment">--修改变量</span></span><br></pre></td></tr></table></figure></div></li>
<li>自定义变量<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅限会话</span></span><br><span class="line"><span class="keyword">set</span> @变量名 <span class="operator">=</span> 值    </span><br><span class="line"><span class="keyword">select</span> @变量名 <span class="comment">-- 查看</span></span><br></pre></td></tr></table></figure></div></li>
<li>局部变量<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅限存储过程</span></span><br><span class="line"><span class="keyword">declare</span> 变量名 <span class="string">&#x27;类型&#x27;</span> [<span class="keyword">default</span> 值]</span><br><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3.流程控制"></a>3.流程控制</h3><ul>
<li>if<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单分支</span></span><br><span class="line">if 条件 <span class="keyword">then</span></span><br><span class="line">elseif <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure></div></li>
<li>参数<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 参数</span></span><br><span class="line"><span class="keyword">IN</span> 输入参数 <span class="keyword">OUT</span> 输出参数 <span class="keyword">INOUT</span> 输入输出参数</span><br></pre></td></tr></table></figure></div></li>
<li>循环：<ul>
<li>while </li>
<li>repeat 满足条件退出循环</li>
<li>loop 配合 leave 退出循环 iterate 继续下次循环 使用<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line">repeat</span><br><span class="line">until 条件 <span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h3 id="4-游标"><a href="#4-游标" class="headerlink" title="4.游标"></a>4.游标</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 游标</span></span><br><span class="line"><span class="keyword">declare</span> 游标名 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br><span class="line"><span class="keyword">open</span> 游标名; <span class="comment">-- 打开游标        </span></span><br><span class="line"><span class="keyword">fetch</span> 游标名 <span class="keyword">into</span> 变量名; <span class="comment">-- 获取数据               </span></span><br><span class="line"><span class="keyword">close</span> 游标名; <span class="comment">-- 关闭游标                                   </span></span><br></pre></td></tr></table></figure></div>

<h3 id="5-异常"><a href="#5-异常" class="headerlink" title="5.异常"></a>5.异常</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 异常                 </span></span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> [<span class="keyword">SQLSTATE</span> <span class="string">&#x27;XXXX&#x27;</span>(异常状态码)<span class="operator">/</span><span class="keyword">not</span> found] 执行操作        </span><br><span class="line">```                 </span><br><span class="line"><span class="operator">!</span>[存储过程游标异常处理.jpg](<span class="operator">/</span>images<span class="operator">/</span>MySQL<span class="operator">/</span>存储过程游标异常处理.jpg)</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 存储函数</span><br><span class="line">```<span class="keyword">sql</span>              </span><br><span class="line"><span class="comment">-- 存储函数 与存储过程类似 只能是IN类型参数 不能有输出类型参数 必须有return返回值                           </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数列表) </span><br><span class="line"><span class="keyword">RETURNS</span> type characters <span class="comment">--必须指定特征类型 </span></span><br><span class="line"><span class="comment">--- 调用函数</span></span><br><span class="line"><span class="keyword">select</span> 函数名(参数列表)</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-索引</title>
    <url>/2023/09/07/MySQL/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(字段名)</span><br><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure></div>

<h3 id="2-索引结构"><a href="#2-索引结构" class="headerlink" title="2.索引结构"></a>2.索引结构</h3><p>由存储引擎实现，包括：</p>
<ul>
<li>B+tree索引<blockquote>
<p>所有元素都会出现在叶子结点，非叶结点起索引作用，叶子结点之间用指针连接。</p>
</blockquote>
</li>
<li>hash索引，不支持范围查找</li>
<li>FullText索引</li>
<li>空间数据索引</li>
</ul>
<h3 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3.索引分类"></a>3.索引分类</h3><ul>
<li>主键索引</li>
<li>唯一索引 避免某数据列中的值重复</li>
<li>普通索引</li>
<li>全文索引<br>根据存储形式又分为：</li>
<li>聚集索引（聚簇索引） 数据与索引存在一块 只会有一个</li>
<li>二级索引 数据与索引分开存储 存主键<div class="note note"><p>若存在主键 主键索引就是聚集索引<br>若不存在主键 使用第一个唯一索引作为聚集索引<br>若都无 INNODB自动生成一个rowid作为隐藏的聚集索引</p>
</div></li>
<li>覆盖索引 要查的数据列正好有索引 无需回表</li>
<li>联合索引 使用表中的多个字段创建索引<blockquote>
<p>在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成</p>
</blockquote>
</li>
</ul>
<p>联合索引，一定要扯最左匹配!</p>
<h4 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h4><p>所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是，当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。<br>假设，我们对(a,b)字段建立一个索引，也就是说，你where后条件为</p>
<p>a &#x3D; 1<br>a &#x3D; 1 and b &#x3D; 2<br>是可以匹配索引的。但是要注意的是~你执行</p>
<p>b&#x3D; 2 and a &#x3D;1<br>也是能匹配到索引的，因为Mysql有优化器会自动调整a,b的顺序与索引顺序一致。<br>相反的，你执行</p>
<p>b &#x3D; 2<br>就匹配不到索引了。<br>而你对(a,b,c,d)建立索引,where后条件为</p>
<p>a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4<br>那么，a,b,c三个字段能用到索引，而d就匹配不到。因为遇到了<code>范围查询</code>！</p>
<p>最左匹配的原理？<br>假设，我们对(a,b)字段建立索引，那么入下图所示<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D.jpg"
                      alt="alt"
                ></p>
<p>如图所示他们是按照a来进行排序，在a相等的情况下，才按b来排序。</p>
<p>因此，我们可以看到a是有序的1，1，2，2，3，3。而b是一种全局无序，局部相对有序状态!<br>什么意思呢？<br>从全局来看，b的值为1，2，1，4，1，2，是无序的，因此直接执行b &#x3D; 2这种查询条件没有办法利用索引。</p>
<p>从局部来看，当a的值确定的时候，b是有序的。例如a &#x3D; 1时，b值为1，2是有序的状态。当a&#x3D;2时候，b的值为1,4也是有序状态。<br>因此，你执行a &#x3D; 1 and b &#x3D; 2是a,b字段能用到索引的。而你执行a &gt; 1 and b &#x3D; 2时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段用不上索引。<br>综上所示，最左匹配原则，在遇到范围查询的时候，就会停止匹配。</p>
<h3 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><h4 id="4-1-查看执行频次"><a href="#4-1-查看执行频次" class="headerlink" title="4.1 查看执行频次"></a>4.1 查看执行频次</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-2-慢查询日志"><a href="#4-2-慢查询日志" class="headerlink" title="4.2 慢查询日志"></a>4.2 慢查询日志</h4><p>定位sql语句进行优化</p>
<ul>
<li>开启慢查询日志<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;        </span><br><span class="line">```     </span><br><span class="line"><span class="operator">-</span> 查看慢查询日志            </span><br><span class="line"><span class="operator">-</span> 设置慢查询日志的阈值              </span><br><span class="line">```<span class="keyword">sql</span>                                </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>;             </span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="4-3-profiling"><a href="#4-3-profiling" class="headerlink" title="4.3 profiling"></a>4.3 profiling</h4><p>用来记录每一句sql执行信息 需要手动打开</p>
<h4 id="4-4-explain"><a href="#4-4-explain" class="headerlink" title="4.4 explain"></a>4.4 explain</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/explain.jpg"
                      alt="explain"
                ></p>
<div class="note default"><p>type: 性能指标</p>
</div>

<h3 id="5-索引使用原则"><a href="#5-索引使用原则" class="headerlink" title="5. 索引使用原则"></a>5. 索引使用原则</h3><div class="note-large default"><div class="notel-title"><p>Warning</p>
</div><div class="notel-content"><ul>
<li>被频繁更新的字段应该慎重建立索引</li>
<li>尽可能的考虑建立联合索引而不是单列索引</li>
<li>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。</li>
</ul>
</div></div>

<h3 id="6-索引失效"><a href="#6-索引失效" class="headerlink" title="6. 索引失效"></a>6. 索引失效</h3><p>最左匹配：查询条件中要有联合索引最左边的字段，否则无法使用索引。</p>
<ul>
<li>范围查询：尽量使用大于等于否则右边条件失效</li>
<li>缺失字段：索引会失效</li>
<li>参与运算</li>
<li>字符串不加引号</li>
<li>模糊查询 xx% 不会失效 %xx失效 前面加%就会失效</li>
<li>or 前后都要有索引</li>
<li>全盘扫描效率大于索引 则索引失效</li>
</ul>
<h3 id="7-索引使用"><a href="#7-索引使用" class="headerlink" title="7. 索引使用"></a>7. 索引使用</h3><ul>
<li>前缀索引 当为一个字符串长度较长的字段建立索引时，可以取前一部分建立索引，这样可以大大节约索引空间，从而提高索引效率。<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> index index_name(<span class="keyword">column</span>(n))</span><br></pre></td></tr></table></figure></div>
至于前缀长度取到多少，可以使用<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="keyword">column</span>, 长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>
这个比例可以用来衡量前缀索引的合理性。</li>
<li>单列索引VS联合索引<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.jpg"
                      alt="联合索引"
                ></li>
<li>覆盖索引 无需回表查询</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>班长竞选</title>
    <url>/2023/09/09/Some%20to%20say/%E7%8F%AD%E9%95%BF%E7%AB%9E%E9%80%89/</url>
    <content><![CDATA[<p>1.尊敬的各位老师亲爱的同学们大家上午好，首先十分感谢学院能给我这次参与竞选班干部的机会。今天我要竞选的职位是班长。</p>
<p>2.我的演讲讲分为以下三部分 自我介绍 个人看法与工作计划 我的优势</p>
<p>3.首先简单做个自我介绍，我叫比鹏飞，年龄22岁，来自山东济南。大二时从数学系转专业到计算机，从此走上不归路。前几年计算机是宇宙机，现在是不是变成生化环计了。开玩笑归开玩笑，我对编程还是有兴趣的，对有趣新奇的技术始终保持着热爱。这是大学期间一些我的实践经历与比较水的奖我也就不多说了吧。</p>
<p>4.下面我要谈谈我对于班长的认识。</p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-comment"></i><p>Note</p>
</div><div class="notel-content"><ul>
<li>首先，作为班长，要以身作则。不仅要对自己负责，更要对班级同学们负责。对于班级的事务、活动，要尽职尽责，合理地协调安排。其次，积极的维护班级荣誉，我们是一个集体，班长要促进班级和谐团结。为大家创造一个良好的学习环境。</li>
<li>扮演好同学与老师之间沟通桥梁的角色，善于倾听同学的声音和意见，并及时的反馈给老师和学院。</li>
<li>JI课业压力大、时间紧迫。我十分愿意与同学们共同解决无论是学业上的困难还是生活中的问题。我乐意尽自己的一份力帮助大家。</li>
</ul>
</div></div>

<p>5.具体说说我会怎么做</p>
<div class="note default"><ul>
<li>最重要的就是服务群众，为同学们争取便利。我会提高处理班级事务的效率，在一些无关紧要的事情上，尽量节约大家的时间。</li>
<li>适当的交际活动我觉得是必要的，能认识更多有趣的人，有利于同学们的全面发展。</li>
<li>再就是要对学院做出贡献，建设学院。同学们的学术成绩是学院进步发展的关键，这需要大家的共同努力。</li>
</ul>
</div>

<p>6.最后，请允许我说一下自己的优势。</p>
<ul>
<li>责任感 </li>
<li>做事专注认真</li>
<li>性格温和 脾气好 很容易相处哈</li>
<li>暑期语言班担任五班班长 期间与老师和同学相处的很愉快 我对自己的表现还算满意</li>
</ul>
<p>当然，我也会有存在一些不足的地方，在座的有比我年龄稍大的同学，处事经验肯定更丰富。我愿意接受大家每一位的意见和建议。如果有做的不够好的，恳请大家指正。</p>
<p>7.最后的最后。我想说，当下的环境大家也都有所了解，但也不用过于焦虑，毕竟咱们计算机专业，瘦死的骆驼比马大。在电影长安三万里中，年轻的李白有生当如此盛世当为大鹏的雄心壮志，最后也只能感叹个人的努力在时代大势面前，就像一盘散沙，本就如沧海一粟。我们每一位同学的心中都有各自想去到的远方，请大家务必相信自己，坚定自己的选择。追风赶月莫停留，平芜尽处是春山，愿你所有坚持，都能换来繁花似锦，衷心祝愿大家两年之后都能遇到一个更好的自己。</p>
]]></content>
      <categories>
        <category>Self</category>
      </categories>
      <tags>
        <tag>Self</tag>
      </tags>
  </entry>
  <entry>
    <title>奔赴</title>
    <url>/2023/09/07/Some%20to%20say/dis_break_01/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Self</category>
      </categories>
      <tags>
        <tag>Self</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-锁</title>
    <url>/2023/09/08/MySQL/%E9%94%81/</url>
    <content><![CDATA[<h3 id="1-锁的分类"><a href="#1-锁的分类" class="headerlink" title="1. 锁的分类"></a>1. 锁的分类</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>锁住整个库 用来数据备份</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><blockquote>
<p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
</blockquote>
<ol>
<li>表锁<blockquote>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
</blockquote>
</li>
<li>元数据锁 表结构<blockquote>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。<br>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
</blockquote>
</li>
<li>意向锁   <blockquote>
<p>意向锁存在的意义在于，使得行锁和表锁能够共存。<br>由数据库引擎控制，当需要对数据行加s锁x锁时执行操作时，INNODB首先会获取所在表的意向锁，若能获得，则可以加s锁x锁。<br>避免了逐行检查是否加了行级锁</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--设置共享锁：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">--设置排他锁：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E6%84%8F%E5%90%91%E9%94%81.jpg"
                     
                ></li>
</ol>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E8%A1%8C%E9%94%81.jpg"
                     
                ></p>
<blockquote>
<p>行级锁是 MySQL 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少<br>INnoDB的行锁是针对索引加的，若不通过索引检索数据，则会对所有记录加锁</p>
</blockquote>
<ul>
<li>间隙锁<blockquote>
<p>间隙锁，锁定一个范围，但不包含本身，如(1,5<br>间隙锁是存储引擎为了防止幻读，而引入的锁机制。间隙锁之间是互不冲突的，因此可以有多个</p>
</blockquote>
</li>
<li>临键锁 （next-key lock）<blockquote>
<p>临键锁，锁定一个范围，并且包含本身</p>
</blockquote>
</li>
</ul>
<h3 id="2-mysql锁在4种事务隔离级别里的应用"><a href="#2-mysql锁在4种事务隔离级别里的应用" class="headerlink" title="2.mysql锁在4种事务隔离级别里的应用"></a>2.mysql锁在4种事务隔离级别里的应用</h3><p>事务的四种隔离级别有：</p>
<ul>
<li>读未提交(Read Uncommitted)</li>
</ul>
<p>此时select语句不加任何锁。此时并发最高，但会产生脏读。</p>
<ul>
<li>读提交(Read Committed, RC)</li>
</ul>
<p>普通select语句是快照读</p>
<p>update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update） 等，除了在外键约束检查和重复键检查时会封锁区间，其他情况都只使用记录锁；</p>
<ul>
<li>可重复读(Repeated Read, RR)</li>
</ul>
<p>普通select语句也是快照读</p>
<p>update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update）则要分情况：</p>
<pre><code>1. 在唯一索引上使用唯一的查询条件，则使用记录锁。如: select * from user where id = 1;其中id建立了唯一索引
2. 在唯一索引上使用 范围查询条件，则使用间隙锁与临键锁。如: select * from user where id &gt;20;
</code></pre>
<ul>
<li>串行化(Serializable)</li>
</ul>
<p>此时所有select语句都会被隐式加锁：select … in share mode.</p>
<h3 id="3-快照读、当前读"><a href="#3-快照读、当前读" class="headerlink" title="3.快照读、当前读"></a>3.快照读、当前读</h3><p>要理解前面四种隔离级别的加锁方式，对于MVCC、快照读、当前读 都是必须要理解的。</p>
<p>MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。</p>
<p>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。</p>
<p>当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>
<div class="note 事务隔离机制与锁"><p>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。<br>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</p>
</div>

<h4 id="什么是多版本并发控制（MVCC：multi-version-concurrency-control-）"><a href="#什么是多版本并发控制（MVCC：multi-version-concurrency-control-）" class="headerlink" title="什么是多版本并发控制（MVCC：multi-version concurrency control ）"></a>什么是多版本并发控制（MVCC：multi-version concurrency control ）</h4><blockquote>
<p>MVCC定义：多版并发控制系统。可认为是行级锁的一个变种，它能够避免更多情况下的加锁操作。<br>作用：避免一些加锁操作，提升并发性能。<br>实现：通过在每行记录的后面保存行的创建时间和过期时间或删除时间（它们是隐藏的），这两个时间实际都是系统的版本号。每开始一个新的事务，版本号都会自动增加。<br>具体原理<br>1.select：innoBD查询时会检查以下两个条件：一个是数据行的版本号早于当前事务的版本号；另一个是行的删除版本号，要么没有，要么大于当前事务的版本号。<br>2.insert&#x2F;delete：innoDB将当前的系统版本号作为新插入(删除)的数据行的版本号。<br>3.update：先新插入一行数据，并将当前系统版本号作为行的版本号，同时将当前系统版本号作为原来行的删除版本号。更新主键时，聚集索引和普通索引都会产生两个版本；而更新非主键时，只要普通索引会产生两个版本。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>银行相关</title>
    <url>/2023/09/10/Some%20to%20say/%E9%93%B6%E8%A1%8C%E8%BD%AF%E5%BC%80%E5%86%B2/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode 剑指offer<br>实习名额很少<br>工行体量大 宇宙第一行<br>总行 软开 是分开招聘的 软开是直属机构<br>其他 保险国企 笔试面试比较水 三大运营商it岗 国家电网 总行 科技岗 软开岗 要求高 9硕 证券 稳定性差 可海投<br>银行有很多机构<br>南瑞集团 总部南京<br>直属中心 不用轮岗 省分大概率会轮岗<br>六大行整体&gt;运营商<br>总部&gt;总部直属&gt;省分&gt;子公司</p>
</blockquote>
]]></content>
      <categories>
        <category>Self</category>
      </categories>
      <tags>
        <tag>Self</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2023/09/10/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;numbers[i]+numbers[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;numbers[i]+numbers[j]) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="note default"><p>以上是一有序数组 若为无序数组 那么双指针无效 请看下题</p>
</div>

<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtable.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a>633. 平方数之和</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">long</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> j=(<span class="type">long</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*i+j*j==c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i*i+j*j&lt;c) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="note default"><p>注意int会溢出</p>
</div>

<h3 id="680-验证回文串"><a href="#680-验证回文串" class="headerlink" title="680. 验证回文串"></a>680. 验证回文串</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">del</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left)==s.charAt(right)) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(del==<span class="number">0</span>)&#123;</span><br><span class="line">                    del++;</span><br><span class="line">                    <span class="keyword">return</span> validPalindrome(s.substring(left,right)) || validPalindrome(s.substring(left+<span class="number">1</span>,right+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<div class="note default"><p>substring(left,right) 左闭右开<br>String.charAt(i) 返回第i个字符<br>String.length() 返回字符串长度</p>
</div>

<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>,p3=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] nums3 = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;m&amp;&amp;p2&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1]&lt;=nums2[p2]) nums3[p3++] = nums1[p1++];</span><br><span class="line">            <span class="keyword">else</span> nums3[p3++] = nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1&lt;m)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p1&lt;m)&#123;</span><br><span class="line">                nums3[p3++] = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2&lt;n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2&lt;n)&#123;</span><br><span class="line">                nums3[p3++] = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m+n;i++)&#123;</span><br><span class="line">            nums1[i] = nums3[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><div class="note default"><p>快慢指针 相遇时 相差的距离为环的长度 </p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode fast,slow;</span><br><span class="line">        fast = slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow  == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/LeetCode/%E7%8E%AF%E5%BD%A2%E5%85%A5%E5%8F%A3.jpg"
                      alt="images"
                ></p>
<h3 id="1679-K-和数对的最大数目"><a href="#1679-K-和数对的最大数目" class="headerlink" title="1679. K 和数对的最大数目"></a>1679. K 和数对的最大数目</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[start]+nums[end];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;k) end--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;k) start++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                end--;</span><br><span class="line">                start++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==t.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==len1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxm</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">chang</span> <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">kuan</span> <span class="operator">=</span> Math.min(height[start],height[end]);</span><br><span class="line">            <span class="keyword">if</span>(maxm&lt;chang*kuan)&#123;</span><br><span class="line">                maxm = chang*kuan;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[start]&lt;height[end]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                chang--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">                chang--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>⭐ left左边都是非零的 right持续向前移动 遇见非0就swap </p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>⭐ 同上题</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一 覆盖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span> ,right =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=val)&#123;</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                left++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二 同上题</span></span><br><span class="line"><span class="comment">// 输入：nums = [0,1,2,2,3,0,4,2], val = 2  </span></span><br><span class="line"><span class="comment">//如果不等于val 两个指针一起走 </span></span><br><span class="line"><span class="comment">//如果等于val 右指针走 左指针留下指向val 当右指针指向不是val时 交换 </span></span><br><span class="line"><span class="comment">//最终结果就是 左指针的左都是满足条件的 左指针的右边都是不满足条件的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=val)&#123; </span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2023/09/09/LeetCode/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h3 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a>455. <a class="link"   href="https://leetcode-cn.com/problems/assign-cookies/" >Assign Cookies <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>Difficulty: <strong>Medium</strong><br>Tags: <code>Greedy</code> <code>Two Pointers</code></p>
<blockquote>
<p>排序 若孩子的胃口大于饼干 则判断下一个饼干 若到了无饼干符合（j&#x3D;&#x3D;n）则结束</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> g.length, n = s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;m&amp;&amp;j&lt;n;i++,j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;g[i]&gt;s[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;n) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a>435. <a class="link"   href="https://leetcode-cn.com/problems/non-overlapping-intervals/" >Non-overlapping Intervals <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>Difficulty: <strong>Medium</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">--wait</span><br></pre></td></tr></table></figure></div>

<h3 id="605-Can-Place-Flowers"><a href="#605-Can-Place-Flowers" class="headerlink" title="605. Can Place Flowers"></a>605. <a class="link"   href="https://leetcode-cn.com/problems/can-place-flowers/" >Can Place Flowers <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>Difficulty: <strong>Easy</strong></p>
<blockquote>
<p>跳格子法 </p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> flowerbed.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len&amp;&amp;n&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==len-<span class="number">1</span>||flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i+=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&lt;=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/09/12/LeetCode/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><div class="note default"><p>快慢指针 相遇时 相差的距离为环的长度 </p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode fast,slow;</span><br><span class="line">        fast = slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow  == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/LeetCode/%E7%8E%AF%E5%BD%A2%E5%85%A5%E5%8F%A3.jpg"
                      alt="images"
                ></p>
<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        ListNode head= <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>),cur = head;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">null</span> &amp;&amp; list2!=<span class="literal">null</span>)&#123; <span class="comment">//注意不是list.next </span></span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">                cur.next=list1;</span><br><span class="line">                list1 = list1.next; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next=list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1!=<span class="literal">null</span>?list1:list2;  <span class="comment">//过于优雅</span></span><br><span class="line">        <span class="keyword">return</span> head.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="note default"><p>什么时候需要用虚拟头结点？我这里总结下：当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。</p>
<p>比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。</p>
</div>


<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        ListNode head1=<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>),cur1 = head1;</span><br><span class="line">        ListNode head2=<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>),cur2 = head2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val&gt;=x)&#123;</span><br><span class="line">                cur2.next = p;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur1.next = p;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">            p=temp;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        cur1.next = head2.next;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="note default"><p>注意：断开原list 如果不断开原链表中的每个节点的 next 指针，那么就会出错，因为结果链表中会包含一个环。<br>总的来说，如果需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的</p>
</div>

<h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a>23. 合并K个升序链表</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;                                    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(lists.length,(a,b)-&gt;(a.val-b.val)); <span class="comment">//大小和排序规则</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>),p=dump;</span><br><span class="line">        <span class="keyword">for</span>(ListNode head:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            p.next = temp;</span><br><span class="line">            <span class="keyword">if</span>(temp.next!=<span class="literal">null</span>) pq.add(temp.next);</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">return</span> head.next; <span class="comment">//删头结点</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="literal">null</span>)&#123; <span class="comment">//因为null无next 所以会报错！</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next=slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="note default"><p>考虑头结点 若删的是头结点 则null.next报错</p>
</div>

<h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">double</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        count = Math.ceil(count/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p>⭐</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="literal">null</span>) p1=headB;</span><br><span class="line">            <span class="keyword">else</span> p1=p1.next;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">null</span>) p2=headA;</span><br><span class="line">            <span class="keyword">else</span> p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
