<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>贪心</title>
    <url>/2023/09/09/LeetCode/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h3 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a>455. <a class="link"   href="https://leetcode-cn.com/problems/assign-cookies/" >Assign Cookies <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>Difficulty: <strong>Medium</strong><br>Tags: <code>Greedy</code> <code>Two Pointers</code></p>
<blockquote>
<p>排序 若孩子的胃口大于饼干 则判断下一个饼干 若到了无饼干符合（j&#x3D;&#x3D;n）则结束</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> g.length, n = s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;m&amp;&amp;j&lt;n;i++,j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;g[i]&gt;s[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;n) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a>435. <a class="link"   href="https://leetcode-cn.com/problems/non-overlapping-intervals/" >Non-overlapping Intervals <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>Difficulty: <strong>Medium</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">--wait</span><br></pre></td></tr></table></figure></div>

<h3 id="605-Can-Place-Flowers"><a href="#605-Can-Place-Flowers" class="headerlink" title="605. Can Place Flowers"></a>605. <a class="link"   href="https://leetcode-cn.com/problems/can-place-flowers/" >Can Place Flowers <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>Difficulty: <strong>Easy</strong></p>
<blockquote>
<p>跳格子法 </p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> flowerbed.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len&amp;&amp;n&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==len-<span class="number">1</span>||flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i+=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&lt;=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-引擎</title>
    <url>/2023/09/09/MySQL/INNODB%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.jpg"
                      alt="image"
                ></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-MVCC</title>
    <url>/2023/09/06/MySQL/MVCC/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-当前读"><a href="#1-当前读" class="headerlink" title="1.当前读"></a>1.当前读</h3><p>当前读就是读取记录的最新版本，读取时还要加上锁，导致其他并发事务无法访问该记录，从而阻塞其他并发事务，因此，其并发度最低。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-快照读"><a href="#2-快照读" class="headerlink" title="2.快照读"></a>2.快照读</h3><p>快照读读取的是记录的可见版本（不一定是最新的），这个读取是基于快照的，即不加锁的。快照读不依赖事务的状态，也不依赖事务的隔离级别，因此，其并发性能最好，但是，其读取的数据可能是过时的。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3.MVCC"></a>3.MVCC</h3><p>维护一个数据的多个版本，使得读写没有冲突。其具体实现，依赖于数据库记录中的三个隐字段、undo日志、ReadView。</p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-lightbulb-on"></i><p>实现原理</p>
</div><div class="notel-content"><ul>
<li>隐藏字段<br>在每行记录后添加两个隐藏列，分别是<br>DB_TRX_ID：事务ID<br>DB_ROLL_PTR：回滚指针指向记录的上一个版本，用于配合undo log，指向上一个版本。<br>DB_ROW_ID：隐藏主键，用于在undo log中定位记录，如果表中没有主键，则会生成一个隐藏的自增ID。</li>
<li>undo日志<br>在修改操作时，不仅记录当前数据的日志，还要记录修改前的日志。修改时记录当前的数据到undolog<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/undolog.jpg"
                      alt="undo log"
                ></li>
<li>ReadView<br>ReadView记录了系统当前活跃事务的ID列表,包含一下四个字段:<blockquote>
<ol>
<li>m_ids:当前活跃的事务ID集合</li>
<li>min_trx_id:最小活跃事务ID</li>
<li>max_trx_id:预分配事务ID,当前最大事务+1（因为事务ID是自增的）</li>
<li>creator_trx_id:ReadView创建者的事务ID</li>
</ol>
</blockquote>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/readView.jpg"
                      alt="readView"
                ></p>
</div></div>

<ul>
<li>在RC隔离级别下的执行过程<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/RC-.jpg"
                      alt="readView"
                ></li>
</ul>
<hr>
<h3 id="4-事务隔离与一致原理"><a href="#4-事务隔离与一致原理" class="headerlink" title="4.事务隔离与一致原理"></a>4.事务隔离与一致原理</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5CMySQL%5C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%8E%E4%B8%80%E8%87%B4%E5%8E%9F%E7%90%86.jpg"
                      alt="readView"
                ></p>
<div class="note-large default"><div class="notel-title"><p>🔚总结</p>
</div><div class="notel-content"><ul>
<li>MVCC+锁实现隔离</li>
<li>redolog实现持久化+undolog实现回滚&#x3D;&#x3D;&gt;事务的持久性 一致 原子<blockquote>
<p>redolog（重做日志）是数据库中的一种日志文件，用于记录数据库中发生的所有更改操作，以便在发生故障时进行恢复。它记录了所有已提交的事务所做的更改，以及在故障恢复期间未提交的事务所做的更改。<br>undolog（撤消日志）是数据库中的另一种日志文件，用于记录在事务回滚期间需要撤消的更改操作。当需要回滚一个事务时，数据库会使用undolog来撤消该事务所做的更改，以便将数据库恢复到回滚之前的状态。</p>
</blockquote>
</li>
</ul>
</div></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86.jpg"
                     
                ></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-SQL优化</title>
    <url>/2023/09/09/MySQL/SQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-插入优化"><a href="#1-插入优化" class="headerlink" title="1.插入优化"></a>1.插入优化</h3><ul>
<li>多条插入</li>
<li>手动开启事务</li>
<li>主键顺序插入</li>
<li>大量插入数据时 采用load指令 加载sql文件</li>
</ul>
<h3 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2.主键优化"></a>2.主键优化</h3><ul>
<li>主键长度小</li>
<li>主键有序</li>
<li>主键不要修改</li>
<li></li>
</ul>
<h3 id="3-Order-by优化"><a href="#3-Order-by优化" class="headerlink" title="3.Order by优化"></a>3.Order by优化</h3><ul>
<li>filesort 查出数据后重新排序 慢</li>
<li>index 利用索引 较快<blockquote>
<p>可以根据需求 添加索引时指定升序还是降序 order的时候就会是用index 否则还是会filesort<br>必须是覆盖查询 否则还是要回表 use filesort<br>最左法则</p>
</blockquote>
</li>
</ul>
<h3 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4.group by优化"></a>4.group by优化</h3><ul>
<li>利用索引 且满足最左法则 则不会走临时表 原因：回到联合索引 首先根据第一个字段排序 然后根据第二个字段排排序 但是直接按第二个字段分组时 他们顺序是乱的 需要排序 就会用到临时表 如果先用第一个字段索引找到 第二个自然就是有序的了 顺序下去能够算出count了</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-事务隔离与锁</title>
    <url>/2023/09/08/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<div class="note-large note"><div class="notel-title"><p>note</p>
</div><div class="notel-content"><p>本质上，事务隔离级别就是为了解决并发访问下的数据一致性问题的。不同的事务隔离级别，解决了不同程度的数据一致性。而我们所说的全局锁、表锁、行级锁等等，其实都是事务隔离级别的具体实现。而 MVCC、意向锁，则是一些局部的性能优化。</p>
</div></div>

<h3 id="1-事务的隔离级别"><a href="#1-事务的隔离级别" class="headerlink" title="1.事务的隔离级别"></a>1.事务的隔离级别</h3><ul>
<li><p>读未提交（Read Uncommitted）<br>读还没有提交的数据 会产生脏读 比如 事务A读取了事务B未提交的数据 然后事务B回滚了 事务A读取的数据就无效了</p>
</li>
<li><p>读已提交（Read Committed）<br>读已经提交的数据 不会产生<code>脏读 </code>但会产生<code>不可重复读</code>是指事务A读取了事务B已经提交的数据 然后事务B修改了数据 事务A再次读取的数据和第一次读取的数据不一样</p>
</li>
<li><p>可重复读（Repeatable Read）<br>这个隔离级别解决了<code>不可重复读</code>的问题，只要是在同一事务范围内，那么读取到的数据就是一样的。对于 MySQL Innodb 来说，其实通过 MVCC 来实现的。但<code>不可重复读</code>隔离级别会产生幻读问题，即对于某个<code>范围</code>的数据读取，前后两次可能读取到不同的结果。</p>
<blockquote>
<p>举个例子：数据库中有 price 为 1、3、5 三个商品，此时 A 事务查询 price &lt; 10 的商品，查询到了 3 个商品。随后 B 事务插入了一条 price 为 7 的商品。接着 A 事务继续查询 price &lt; 10 的商品，这次却查询到了 4 个商品。可以看到「幻读」与「不可重复读」是有些类似的，只是「不可重复读」更多指的是某一条记录，而「幻读」指的则是某个范围数据。对于 MySQL Innodb 来说，其通过行级锁级别的 Gap Lock 解决了幻读的问题。</p>
</blockquote>
</li>
<li><p>串行化（Serializable）<br>串行化，指的是所有事务串行执行。 这个就最简单了，不用去竞争，一个个去执行，但是效率也是最低的。</p>
</li>
</ul>
<h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2.锁"></a>2.锁</h3><ul>
<li>表级的意向排它锁（IX）：lock mode IX。</li>
<li>表级的插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention</li>
<li>行级的记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap</li>
<li>行级的间隙锁（LOCK_GAP）: lock_mode X locks gap before rec</li>
<li>行级的 Next-key 锁（LOCK_ORNIDARY）: lock_mode X<br>在 Innodb 存储引擎中，我们可以通过下面的命令来查询锁的情况。<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 开启锁的日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_status_output_locks<span class="operator">=</span><span class="keyword">on</span>; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查看innodb引擎的信息(包含锁的信息)</span><br><span class="line"><span class="keyword">show</span> engine innodb status\G;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-存储过程</title>
    <url>/2023/09/07/MySQL/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$ <span class="comment">-- 修改SQL语句的结束符为$$</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(参数列表) <span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 存储过程体</span></span><br><span class="line"><span class="keyword">END</span> $$ <span class="comment">-- 存储过程结束  </span></span><br><span class="line">DELIMITER ; <span class="comment">-- 修改回原来的结束符</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><ul>
<li>系统变量<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">global</span> variables <span class="comment">--支持模糊查询</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span> <span class="comment">--查看变量</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span> <span class="comment">--修改变量</span></span><br></pre></td></tr></table></figure></div></li>
<li>自定义变量<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅限会话</span></span><br><span class="line"><span class="keyword">set</span> @变量名 <span class="operator">=</span> 值    </span><br><span class="line"><span class="keyword">select</span> @变量名 <span class="comment">-- 查看</span></span><br></pre></td></tr></table></figure></div></li>
<li>局部变量<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅限存储过程</span></span><br><span class="line"><span class="keyword">declare</span> 变量名 <span class="string">&#x27;类型&#x27;</span> [<span class="keyword">default</span> 值]</span><br><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3.流程控制"></a>3.流程控制</h3><ul>
<li>if<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单分支</span></span><br><span class="line">if 条件 <span class="keyword">then</span></span><br><span class="line">elseif <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure></div></li>
<li>参数<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 参数</span></span><br><span class="line"><span class="keyword">IN</span> 输入参数 <span class="keyword">OUT</span> 输出参数 <span class="keyword">INOUT</span> 输入输出参数</span><br></pre></td></tr></table></figure></div></li>
<li>循环：<ul>
<li>while </li>
<li>repeat 满足条件退出循环</li>
<li>loop 配合 leave 退出循环 iterate 继续下次循环 使用<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line">repeat</span><br><span class="line">until 条件 <span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h3 id="4-游标"><a href="#4-游标" class="headerlink" title="4.游标"></a>4.游标</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 游标</span></span><br><span class="line"><span class="keyword">declare</span> 游标名 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br><span class="line"><span class="keyword">open</span> 游标名; <span class="comment">-- 打开游标        </span></span><br><span class="line"><span class="keyword">fetch</span> 游标名 <span class="keyword">into</span> 变量名; <span class="comment">-- 获取数据               </span></span><br><span class="line"><span class="keyword">close</span> 游标名; <span class="comment">-- 关闭游标                                   </span></span><br></pre></td></tr></table></figure></div>

<h3 id="5-异常"><a href="#5-异常" class="headerlink" title="5.异常"></a>5.异常</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 异常                 </span></span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> [<span class="keyword">SQLSTATE</span> <span class="string">&#x27;XXXX&#x27;</span>(异常状态码)<span class="operator">/</span><span class="keyword">not</span> found] 执行操作        </span><br><span class="line">```                 </span><br><span class="line"><span class="operator">!</span>[存储过程游标异常处理.jpg](<span class="operator">/</span>images<span class="operator">/</span>MySQL<span class="operator">/</span>存储过程游标异常处理.jpg)</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 存储函数</span><br><span class="line">```<span class="keyword">sql</span>              </span><br><span class="line"><span class="comment">-- 存储函数 与存储过程类似 只能是IN类型参数 不能有输出类型参数 必须有return返回值                           </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数列表) </span><br><span class="line"><span class="keyword">RETURNS</span> type characters <span class="comment">--必须指定特征类型 </span></span><br><span class="line"><span class="comment">--- 调用函数</span></span><br><span class="line"><span class="keyword">select</span> 函数名(参数列表)</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-索引</title>
    <url>/2023/09/07/MySQL/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(字段名)</span><br><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure></div>

<h3 id="2-索引结构"><a href="#2-索引结构" class="headerlink" title="2.索引结构"></a>2.索引结构</h3><p>由存储引擎实现，包括：</p>
<ul>
<li>B+tree索引<blockquote>
<p>所有元素都会出现在叶子结点，非叶结点起索引作用，叶子结点之间用指针连接。</p>
</blockquote>
</li>
<li>hash索引，不支持范围查找</li>
<li>FullText索引</li>
<li>空间数据索引</li>
</ul>
<h3 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3.索引分类"></a>3.索引分类</h3><ul>
<li>主键索引</li>
<li>唯一索引 避免某数据列中的值重复</li>
<li>普通索引</li>
<li>全文索引<br>根据存储形式又分为：</li>
<li>聚集索引（聚簇索引） 数据与索引存在一块 只会有一个</li>
<li>二级索引 数据与索引分开存储 存主键<div class="note note"><p>若存在主键 主键索引就是聚集索引<br>若不存在主键 使用第一个唯一索引作为聚集索引<br>若都无 INNODB自动生成一个rowid作为隐藏的聚集索引</p>
</div></li>
<li>覆盖索引 要查的数据列正好有索引 无需回表</li>
<li>联合索引 使用表中的多个字段创建索引<blockquote>
<p>在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成</p>
</blockquote>
</li>
</ul>
<p>联合索引，一定要扯最左匹配!</p>
<h4 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h4><p>所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是，当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。<br>假设，我们对(a,b)字段建立一个索引，也就是说，你where后条件为</p>
<p>a &#x3D; 1<br>a &#x3D; 1 and b &#x3D; 2<br>是可以匹配索引的。但是要注意的是~你执行</p>
<p>b&#x3D; 2 and a &#x3D;1<br>也是能匹配到索引的，因为Mysql有优化器会自动调整a,b的顺序与索引顺序一致。<br>相反的，你执行</p>
<p>b &#x3D; 2<br>就匹配不到索引了。<br>而你对(a,b,c,d)建立索引,where后条件为</p>
<p>a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4<br>那么，a,b,c三个字段能用到索引，而d就匹配不到。因为遇到了<code>范围查询</code>！</p>
<p>最左匹配的原理？<br>假设，我们对(a,b)字段建立索引，那么入下图所示<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D.jpg"
                      alt="alt"
                ></p>
<p>如图所示他们是按照a来进行排序，在a相等的情况下，才按b来排序。</p>
<p>因此，我们可以看到a是有序的1，1，2，2，3，3。而b是一种全局无序，局部相对有序状态!<br>什么意思呢？<br>从全局来看，b的值为1，2，1，4，1，2，是无序的，因此直接执行b &#x3D; 2这种查询条件没有办法利用索引。</p>
<p>从局部来看，当a的值确定的时候，b是有序的。例如a &#x3D; 1时，b值为1，2是有序的状态。当a&#x3D;2时候，b的值为1,4也是有序状态。<br>因此，你执行a &#x3D; 1 and b &#x3D; 2是a,b字段能用到索引的。而你执行a &gt; 1 and b &#x3D; 2时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段用不上索引。<br>综上所示，最左匹配原则，在遇到范围查询的时候，就会停止匹配。</p>
<h3 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><h4 id="4-1-查看执行频次"><a href="#4-1-查看执行频次" class="headerlink" title="4.1 查看执行频次"></a>4.1 查看执行频次</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-2-慢查询日志"><a href="#4-2-慢查询日志" class="headerlink" title="4.2 慢查询日志"></a>4.2 慢查询日志</h4><p>定位sql语句进行优化</p>
<ul>
<li>开启慢查询日志<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;        </span><br><span class="line">```     </span><br><span class="line"><span class="operator">-</span> 查看慢查询日志            </span><br><span class="line"><span class="operator">-</span> 设置慢查询日志的阈值              </span><br><span class="line">```<span class="keyword">sql</span>                                </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>;             </span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="4-3-profiling"><a href="#4-3-profiling" class="headerlink" title="4.3 profiling"></a>4.3 profiling</h4><p>用来记录每一句sql执行信息 需要手动打开</p>
<h4 id="4-4-explain"><a href="#4-4-explain" class="headerlink" title="4.4 explain"></a>4.4 explain</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/explain.jpg"
                      alt="explain"
                ></p>
<div class="note default"><p>type: 性能指标</p>
</div>

<h3 id="5-索引使用原则"><a href="#5-索引使用原则" class="headerlink" title="5. 索引使用原则"></a>5. 索引使用原则</h3><div class="note-large default"><div class="notel-title"><p>Warning</p>
</div><div class="notel-content"><ul>
<li>被频繁更新的字段应该慎重建立索引</li>
<li>尽可能的考虑建立联合索引而不是单列索引</li>
<li>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。</li>
</ul>
</div></div>

<h3 id="6-索引失效"><a href="#6-索引失效" class="headerlink" title="6. 索引失效"></a>6. 索引失效</h3><p>最左匹配：查询条件中要有联合索引最左边的字段，否则无法使用索引。</p>
<ul>
<li>范围查询：尽量使用大于等于否则右边条件失效</li>
<li>缺失字段：索引会失效</li>
<li>参与运算</li>
<li>字符串不加引号</li>
<li>模糊查询 xx% 不会失效 %xx失效 前面加%就会失效</li>
<li>or 前后都要有索引</li>
<li>全盘扫描效率大于索引 则索引失效</li>
</ul>
<h3 id="7-索引使用"><a href="#7-索引使用" class="headerlink" title="7. 索引使用"></a>7. 索引使用</h3><ul>
<li>前缀索引 当为一个字符串长度较长的字段建立索引时，可以取前一部分建立索引，这样可以大大节约索引空间，从而提高索引效率。<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> index index_name(<span class="keyword">column</span>(n))</span><br></pre></td></tr></table></figure></div>
至于前缀长度取到多少，可以使用<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="keyword">column</span>, 长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>
这个比例可以用来衡量前缀索引的合理性。</li>
<li>单列索引VS联合索引<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.jpg"
                      alt="联合索引"
                ></li>
<li>覆盖索引 无需回表查询</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-视图</title>
    <url>/2023/09/07/MySQL/%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称 <span class="keyword">AS</span> 查询语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改视图 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称 <span class="keyword">AS</span> 查询语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图                                 </span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名称;                                                                             </span><br><span class="line"><span class="comment">-- 查看视图                                                     </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-检查选项cascaded"><a href="#2-检查选项cascaded" class="headerlink" title="2.检查选项cascaded"></a>2.检查选项cascaded</h3> <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"><span class="comment">-- cascaded 级联 向下传递验证</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"> <span class="comment">--- local 本地 只检查当前视图  不会再向下验证。 eg:v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，只检查v2，不会检查v2的关联视图v1。</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-视图的更新"><a href="#3-视图的更新" class="headerlink" title="3.视图的更新"></a>3.视图的更新</h3><p>视图必须与基础表一一对应才能增删改</p>
<h3 id="4-视图作用"><a href="#4-视图作用" class="headerlink" title="4.视图作用"></a>4.视图作用</h3><ul>
<li>简单 将常用的sql封装成视图 简化操作</li>
<li>安全 权限分配</li>
<li>数据独立 屏蔽真实的表结构</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶-锁</title>
    <url>/2023/09/08/MySQL/%E9%94%81/</url>
    <content><![CDATA[<h3 id="1-锁的分类"><a href="#1-锁的分类" class="headerlink" title="1. 锁的分类"></a>1. 锁的分类</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>锁住整个库 用来数据备份</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><blockquote>
<p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
</blockquote>
<ol>
<li>表锁<blockquote>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
</blockquote>
</li>
<li>元数据锁 表结构<blockquote>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。<br>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
</blockquote>
</li>
<li>意向锁   <blockquote>
<p>意向锁存在的意义在于，使得行锁和表锁能够共存。<br>由数据库引擎控制，当需要对数据行加s锁x锁时执行操作时，INNODB首先会获取所在表的意向锁，若能获得，则可以加s锁x锁。<br>避免了逐行检查是否加了行级锁</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--设置共享锁：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">--设置排他锁：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E6%84%8F%E5%90%91%E9%94%81.jpg"
                     
                ></li>
</ol>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/MySQL/%E8%A1%8C%E9%94%81.jpg"
                     
                ></p>
<blockquote>
<p>行级锁是 MySQL 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少<br>INnoDB的行锁是针对索引加的，若不通过索引检索数据，则会对所有记录加锁</p>
</blockquote>
<ul>
<li>间隙锁<blockquote>
<p>间隙锁，锁定一个范围，但不包含本身，如(1,5<br>间隙锁是存储引擎为了防止幻读，而引入的锁机制。间隙锁之间是互不冲突的，因此可以有多个</p>
</blockquote>
</li>
<li>临键锁 （next-key lock）<blockquote>
<p>临键锁，锁定一个范围，并且包含本身</p>
</blockquote>
</li>
</ul>
<h3 id="2-mysql锁在4种事务隔离级别里的应用"><a href="#2-mysql锁在4种事务隔离级别里的应用" class="headerlink" title="2.mysql锁在4种事务隔离级别里的应用"></a>2.mysql锁在4种事务隔离级别里的应用</h3><p>事务的四种隔离级别有：</p>
<ul>
<li>读未提交(Read Uncommitted)</li>
</ul>
<p>此时select语句不加任何锁。此时并发最高，但会产生脏读。</p>
<ul>
<li>读提交(Read Committed, RC)</li>
</ul>
<p>普通select语句是快照读</p>
<p>update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update） 等，除了在外键约束检查和重复键检查时会封锁区间，其他情况都只使用记录锁；</p>
<ul>
<li>可重复读(Repeated Read, RR)</li>
</ul>
<p>普通select语句也是快照读</p>
<p>update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update）则要分情况：</p>
<pre><code>1. 在唯一索引上使用唯一的查询条件，则使用记录锁。如: select * from user where id = 1;其中id建立了唯一索引
2. 在唯一索引上使用 范围查询条件，则使用间隙锁与临键锁。如: select * from user where id &gt;20;
</code></pre>
<ul>
<li>串行化(Serializable)</li>
</ul>
<p>此时所有select语句都会被隐式加锁：select … in share mode.</p>
<h3 id="3-快照读、当前读"><a href="#3-快照读、当前读" class="headerlink" title="3.快照读、当前读"></a>3.快照读、当前读</h3><p>要理解前面四种隔离级别的加锁方式，对于MVCC、快照读、当前读 都是必须要理解的。</p>
<p>MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。</p>
<p>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。</p>
<p>当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>
<div class="note 事务隔离机制与锁"><p>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。<br>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</p>
</div>

<h4 id="什么是多版本并发控制（MVCC：multi-version-concurrency-control-）"><a href="#什么是多版本并发控制（MVCC：multi-version-concurrency-control-）" class="headerlink" title="什么是多版本并发控制（MVCC：multi-version concurrency control ）"></a>什么是多版本并发控制（MVCC：multi-version concurrency control ）</h4><blockquote>
<p>MVCC定义：多版并发控制系统。可认为是行级锁的一个变种，它能够避免更多情况下的加锁操作。<br>作用：避免一些加锁操作，提升并发性能。<br>实现：通过在每行记录的后面保存行的创建时间和过期时间或删除时间（它们是隐藏的），这两个时间实际都是系统的版本号。每开始一个新的事务，版本号都会自动增加。<br>具体原理<br>1.select：innoBD查询时会检查以下两个条件：一个是数据行的版本号早于当前事务的版本号；另一个是行的删除版本号，要么没有，要么大于当前事务的版本号。<br>2.insert&#x2F;delete：innoDB将当前的系统版本号作为新插入(删除)的数据行的版本号。<br>3.update：先新插入一行数据，并将当前系统版本号作为行的版本号，同时将当前系统版本号作为原来行的删除版本号。更新主键时，聚集索引和普通索引都会产生两个版本；而更新非主键时，只要普通索引会产生两个版本。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>JAVA</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>奔赴</title>
    <url>/2023/09/07/Some%20to%20say/dis_break_01/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Self</category>
      </categories>
      <tags>
        <tag>Tour</tag>
      </tags>
  </entry>
  <entry>
    <title>班长竞选</title>
    <url>/2023/09/09/Some%20to%20say/%E7%8F%AD%E9%95%BF%E7%AB%9E%E9%80%89/</url>
    <content><![CDATA[<p>1.尊敬的各位老师亲爱的同学们大家上午好，首先十分感谢学院能给我这次参与竞选班干部的机会。今天我要竞选的职位是班长。</p>
<p>2.我的演讲讲分为以下三部分 自我介绍 个人看法与工作计划 我的优势</p>
<p>3.首先简单做个自我介绍，我叫比鹏飞，年龄22岁，来自山东济南。大二时从数学系转专业到计算机，从此走上不归路。前几年计算机是宇宙机，现在是不是变成生化环计了。开玩笑归开玩笑，我对编程还是有兴趣的，对技术保持热爱。这是大学期间一些我的实践经历与比较水的奖我也就不多说了吧。</p>
<p>4.下面我要谈谈我对于班长的认识。</p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-lightbulb-on"></i><p>note</p>
</div><div class="notel-content"><ul>
<li>首先，作为班长，要以身作则。不仅要对自己负责，更要对班级同学们负责。对于班级的事务活动，要尽职尽责，合理协调安排。其次，积极的维护班级荣誉，我们是一个集体，班长要促进班级和谐团结。为大家创造一个良好的学习环境。</li>
<li>扮演好同学与老师之间沟通桥梁的角色，善于倾听同学的声音和意见，并及时的反馈给老师和学院。</li>
<li>ppt</li>
</ul>
</div></div>

<p>5.具体说说我会怎么做</p>
<div class="note-large default"><div class="notel-title"><i class="notel-icon fa-solid fa-lightbulb-on"></i><p>note</p>
</div><div class="notel-content"><ul>
<li>最重要的就是服务群众，为同学们争取便利。我会提高处理班级事务的效率，在一些无关紧要的事情上，尽量节约大家的时间。</li>
<li>适当的交际活动我觉得是必要的，能认识更多有趣的人，有利于同学们的全面发展。</li>
<li>再就是要对学院做出贡献，建设学院。同学们的学术成绩是学院进步发展的关键，这需要大家的共同努力。</li>
</ul>
</div></div>

<p>6.最后，请允许我尬吹一下个人优势。123 暑期语言班担任五班班长 与老师和同学相处的很愉快 我对自己的表现还算满意吧</p>
<p>7.最后的最后。我想说，当下的环境大家也都有所了解，不过也不用过于焦虑，毕竟计算机通信，瘦死的骆驼比马大。在电影长安三万里中，年轻的李白有生当如此盛世当为大鹏的雄心壮志。最后也只能感叹个人的努力在时代大势面前，就像一盘散沙，本就如沧海一粟。我们每一位同学的心中都有各自想去到的远方，请大家务必相信自己，坚定自己的选择，坚持走下去。我衷心祝愿大家两年之后都能遇到一个更好的自己。</p>
]]></content>
      <categories>
        <category>Self</category>
      </categories>
      <tags>
        <tag>Fight</tag>
      </tags>
  </entry>
</search>
